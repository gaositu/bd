var ls = window.localStorage;
var lsf = ls.getItem( 'f' );
var lsh = ls.getItem( 'h' );
ls.clear();
ls.setItem( 'f', lsf );
ls.setItem( 'h', lsh );
ls.setItem( 'v', '1.1' );
// - - - - - - - - - -
// 1-css
// 2-css3
// 3-js
ls.setItem('3_js闭包','闭包就是内部函数通过某种方式使其可见范围超出了其定义的范围,这就产生了一个在其定义范围内的闭包.');
// 4-jq
// 5-h5
// 6-pm
// 7-sql
// 8-interview
ls.setItem('8_关于闭包','概念：闭包就是内部函数通过某种方式使其可见范围超出了其定义的范围,这就产生了一个在其定义范围内的闭包<br/>function a(){<br/>var i=0;<br/>function b(){<br/>alert(++i);<br/>}<br/>return b;<br/>}<br/>var c = a();<br/>c();<br/>闭包函数返回时,该函数内部变量处于激活状态,函数所在栈区依然保留<br/>总结下<br/>1，闭包外层是个函数.<br/>2，闭包内部都有函数.<br/>3，闭包会return内部函数.<br/>4，闭包返回的函数内部不能有return.(因为这样就真的结束了)<br/>5，执行闭包后,闭包内部变量会存在,而闭包内部函数的内部变量不会存在<br/>闭包的应用场景<br/>1、保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。<br/>2、在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。<br/>js闭包的用途<br/>1 匿名自执行函数<br/>2 缓存<br/>3 实现封装<br/>4 实现面向对象中的对象');
// 9-about
// - - - - - - - - - -
try{jsonp2()}catch(e){}

